![image](https://raw.githubusercontent.com/9527dong/demo/master/RabbitMQ/src/main/resources/img/work.png)

>Work模式

P：消息的生产者
C：消息的消费者
红色：队列

一个生产者、2个消费者。一个消息只能被一个消费者获取。

测试结果：

1. 消费者1和消费者2获取到的消息内容是不同的，同一个消息只能被一个消费者获取。
2. 消费者中添加`channel.basicQos(1);`可以实现消费者1和消费者2能者多劳的效果，消费者1比消费者2获取到的消息更多。
3. 消费者中不添加`channel.basicQos(1);`这行代码，则消费者1和消费者2获取到的消息的数量是相同的，一个是奇数一个是偶数。

### 消息确认模式
消费者从队列中获取消息，服务端如何知道消息已经被消费呢？

1. 模式1：自动确认，消费者1(Recv)使用的是自动确认模式。
	只要消息从队列中获取，无论消费者获取到消息后是否成功消息，都认为是消息已经成功消费。
2. 模式2：手动确认，消费者2(Recv2)使用的是手动确认模式。
	消费者从队列中获取消息后，服务器会将该消息标记为不可用状态，等待消费者的反馈，如果消费者一直没有反馈，那么该消息将一直处于不可用状态。


  